from functools import reduce
from typing import List, Optional, Dict, Any, cast
from dataclasses import dataclass, astuple

import numpy as np

from .phreeqc import PHREEQC

###############################################################################
@dataclass
class Bound:
    lower: float
    upper: float

    ###########################################################################
    def __post_init__(self):
        if self.lower > self.upper:
            raise RuntimeError('Lower must be less than or equal to upper')

###############################################################################
@dataclass
class Problem:
    names: List[str]
    bounds: List[Bound]
    num_vars: int
    db_template_filename: str
    output_filename: str
    input_filename: str

    ###########################################################################
    def __post_init__(self):
        if self.num_vars is None:
            self.num_vars = len(self.names)

        if self.num_vars == 0:
            raise RuntimeError('Must specify a non-zero number of vars')

        if len(self.names) != len(self.bounds):
            raise RuntimeError('Must specify equal number of names and bounds')

    ###########################################################################
    @staticmethod
    def from_dict(problem: Dict[str, Any]):
        return Problem(**problem)

    ###########################################################################
    def to_salib(self):
        return {'names': self.names, 'bounds': [astuple(x) for x in self.bounds], 'num_vars': self.num_vars}


###############################################################################
# get_random_values
###############################################################################
def get_random_values(bounds: List[Bound], num_vars: int) -> np.ndarray:
    '''
    returns a matrix of random values between lower and upper

    lower, upper: lists of bounds to generate within
    num_iter: number of sets to generate
    return: num_iter by len(lower) matrix
    '''

    # generate 1st row
    matrix = None
    for row in range(num_vars):
        values = np.zeros(len(bounds))
        for i, bound in enumerate(bounds):
            values[i] = np.random.uniform(bound.lower, bound.upper)
        if matrix is None:
            matrix = values
        else:
            matrix = np.vstack((matrix, values))

    return cast(np.ndarray, matrix)


###############################################################################
class SimulationRunner:
    ###########################################################################
    def __init__(self, phreeqc: PHREEQC) -> None:
        self.phreeqc = phreeqc
        return

    ###########################################################################
    def run_problem(self, problem: Problem, values: np.ndarray, analytes: Optional[List[str]]=None) -> List[np.ndarray]:
        '''
        Run a problem simulation using the specified values.
        '''
        return self.run_sims(values_mtrx=values,
                             pars=problem.names,
                             input_filename=problem.input_filename,
                             output_filename=problem.output_filename,
                             db_template_filename=problem.db_template_filename,
                             analytes=analytes)

    ###########################################################################
    def run_random_problem(self, problem: Problem, analytes: Optional[List[str]]=None) -> List[np.ndarray]:
        '''
        Generates randomized values using the problem bounds,
        and then runs the given problem simulation
        '''
        self.generated_values = get_random_values(problem.bounds, problem.num_vars)
        return self.run_problem(problem=problem, values=self.generated_values, analytes=analytes)

    ###########################################################################
    def run_sims(self,
                 values_mtrx: np.ndarray,
                 pars: List[str],
                 input_filename: str,
                 output_filename: str,
                 db_template_filename: str,
                 analytes: Optional[List[str]] = None) -> List[np.ndarray]:
        '''
        runs a phreeqc simulation for each row of parameters in values_mtrx
        requires various path variables to be set correctly at beginning of file

        values_mtrx: matrix of values generated from get_random_values or similar function
        analytes: list of element keywords to search for in .out file generated by phreeqc
        return: list of np arrays of [sim#, analyte1, analyte2...] (format is kind of awkward
        '''

        if analytes is None:
            analytes = ['pH', 'U']

        obs_all = []
        for values in values_mtrx:
            self.phreeqc.write_db_from_template(template_filename=db_template_filename,
                                                pars=pars,
                                                values=values)
            result = self.phreeqc.run(db_filename=db_template_filename, in_filename=input_filename, analytes=analytes)
            obs_all.append(result.output)

        return obs_all
